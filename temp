#https://leetcode.com/problems/different-ways-to-add-parentheses/description/

# 2*3-4*5
# 2*3-4*5
# 2 * all_possible_results(3-4*5)
# 
# 3+5, (3+5)
# 3+5*2, (3+5)*2, 3+(5*2)
# 3+5*2-1, (3+5)*2-1, 3+(5*2)-1, 3+(5*2-1)


## (2) (3,4,5)
# (2*(3-(4*5))) = -34 
# (2*((3-4)*5)) = -10 


## (2,3,4) (5)
# ((2*(3-4))*5) = -10 
# (((2*3)-4)*5) = 10

## (2,3) (4,5)
# ((2*3)-(4*5)) = -14 


## (2) (3,4,5)
## (2,3) (4,5)
## (2,3,4) (5)


class Solution(object):
    def diffWaysToCompute(self, input):
        """
        :type input: str
        :rtype: List[int]
        """
        

    # 2*3-4*5
    # number: [2,3,4,5]
    # operator = [+,-,*]
    # () (2,3,4,5)
    # (2,3,4,5) ()
    
    
      # process input
      numbers = input.split('[+-*]')
      operators = []
      for i in range(input):
        if i == '+' or i == '-' or i == '*':
          operators.append(i)
      
      return self.helper(numbers, operators)

    #  + 
    def helper(self, numbers, operators):
      
      if len(numbers) == 1:
        return [numbers[0]]
      
      for i in range(1, len(numbers)): # i = (1, 2, 3) # T(1) * T(n-1) + T(2) * 
        first_part = self.helper(nums[:i]) # T(i)
        second_part = self.helper(nums[i:]) # T(n-i)  O(n)
        if operator[i-1] == '+':
          # (2) (3,4,5), i=1
          # n elements '
          # T(n): number of unit computations of n elements
          
          # T(n) = T(1) * T(n-1) + T(2) * T(n-2) + ... + T(n-1) * T(1) = O(n^n)
          # T(1) = 1
          # T(2) = T(1) * T(1) + T(1) * T(1) = 2
          # T(3) = T(1) * (2) + T(2) * (1) = 4
          for res1 in first_part: # i elements T(i)
            for res2 in second_part: # n-i elements T(n-1)
              res.apppend(res1 + res2)  # output_size(i)*output_size(n-i)
              
        elif operator[i] == '-':
          for res1 in first_part:
            for res2 in second_part:
              res.apppend(res1 - res2)        
        elif operator[i] == '*':
          for res1 in first_part:
            for res2 in second_part:
              res.apppend(res1 * res2)
        
        return res
          

          
          
          
          
          #https://leetcode.com/problems/different-ways-to-add-parentheses/description/

# 2*3-4*5
# 2*3-4*5
# 2 * all_possible_results(3-4*5)
# 
# 3+5, (3+5)
# 3+5*2, (3+5)*2, 3+(5*2)
# 3+5*2-1, (3+5)*2-1, 3+(5*2)-1, 3+(5*2-1)


## (2) (3,4,5)
# (2*(3-(4*5))) = -34 
# (2*((3-4)*5)) = -10 


## (2,3,4) (5)
# ((2*(3-4))*5) = -10 
# (((2*3)-4)*5) = 10

## (2,3) (4,5)
# ((2*3)-(4*5)) = -14 


## (2) (3,4,5)
## (2,3) (4,5)
## (2,3,4) (5)


class Solution(object):
    def diffWaysToCompute(self, input):
        """
        :type input: str
        :rtype: List[int]
        """
        

    # 2*3-4*5
    # number: [2,3,4,5]
    # operator = [+,-,*]
    # () (2,3,4,5)
    # (2,3,4,5) ()
    
    
      # process input
      numbers = input.split('[+-*]')
      operators = []
      for i in range(input):
        if i == '+' or i == '-' or i == '*':
          operators.append(i)
      
      return self.helper(numbers, operators)

    #  + 
    def helper(self, numbers, operators):
      
      if len(numbers) == 1:
        return [numbers[0]]
      
      for i in range(1, len(numbers)): # i = (1, 2, 3) # T(1) * T(n-1) + T(2) * 
        first_part = self.helper(nums[:i]) # T(i)
        second_part = self.helper(nums[i:]) # T(n-i)  O(n)
        if operator[i-1] == '+':
          # (2) (3,4,5), i=1
          # n elements '
          # T(n): number of unit computations of n elements
          
          # T(n) = T(1) * T(n-1) + T(2) * T(n-2) + ... + T(n-1) * T(1) = O(n^n)
          # T(1) = 1
          # T(2) = T(1) * T(1) + T(1) * T(1) = 2
          # T(3) = T(1) * (2) + T(2) * (1) = 4
          for res1 in first_part: # i elements T(i)
            for res2 in second_part: # n-i elements T(n-1)
              res.apppend(res1 + res2)  # output_size(i)*output_size(n-i)
              
        elif operator[i] == '-':
          for res1 in first_part:
            for res2 in second_part:
              res.apppend(res1 - res2)        
        elif operator[i] == '*':
          for res1 in first_part:
            for res2 in second_part:
              res.apppend(res1 * res2)
        
        return res
          

          
          
          
          
          